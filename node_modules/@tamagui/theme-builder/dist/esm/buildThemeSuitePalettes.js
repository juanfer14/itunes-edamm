import { hsla, parseToHsla } from "color2k";
const paletteSize = 12, generateColorPalette = ({
  theme,
  scheme,
  forAccent
}) => {
  const baseTheme = forAccent && theme.accent || theme, { anchors } = baseTheme;
  let palette = [];
  const add = (h, s, l) => {
    palette.push(hsla(h, s, l, 1));
  }, numAnchors = Object.keys(anchors).length;
  for (const [anchorIndex, anchor] of anchors.entries()) {
    const [h, s, l] = [anchor.hue[scheme], anchor.sat[scheme], anchor.lum[scheme]];
    if (anchorIndex !== 0) {
      const lastAnchor = anchors[anchorIndex - 1], steps = anchor.index - lastAnchor.index, lastHue = lastAnchor.hue[scheme], lastSat = lastAnchor.sat[scheme], lastLum = lastAnchor.lum[scheme], stepHue = (lastHue - h) / steps, stepSat = (lastSat - s) / steps, stepLum = (lastLum - l) / steps;
      for (let step = lastAnchor.index + 1; step < anchor.index; step++) {
        const str = anchor.index - step;
        add(h + stepHue * str, s + stepSat * str, l + stepLum * str);
      }
    }
    if (add(h, s, l), anchorIndex === numAnchors - 1 && palette.length < paletteSize)
      for (let step = anchor.index + 1; step < paletteSize; step++)
        add(h, s, l);
  }
  const [background] = palette, foreground = palette[palette.length - 1], transparentValues = [background, foreground].map((color) => {
    const [h, s, l] = parseToHsla(color);
    return [
      hsla(h, s, l, 0),
      hsla(h, s, l, 0.25),
      hsla(h, s, l, 0.5),
      hsla(h, s, l, 0.75)
    ];
  }), reverseForeground = [...transparentValues[1]].reverse();
  if (palette = [...transparentValues[0], ...palette, ...reverseForeground], theme.accent) {
    const accentPalette = generateColorPalette({
      theme: theme.accent,
      scheme
    });
    palette.unshift(accentPalette[11]), palette.push(accentPalette[accentPalette.length - 6]);
  } else
    palette.unshift("rgba(0,0,0,0)"), palette.push("rgba(0,0,0,0)");
  return palette;
};
function getThemeSuitePalettes(theme) {
  return {
    light: generateColorPalette({ theme, scheme: "light" }),
    lightAccent: generateColorPalette({ theme, scheme: "light", forAccent: !0 }),
    dark: generateColorPalette({ theme, scheme: "dark" }),
    darkAccent: generateColorPalette({ theme, scheme: "dark", forAccent: !0 })
  };
}
export {
  getThemeSuitePalettes
};
//# sourceMappingURL=buildThemeSuitePalettes.js.map
