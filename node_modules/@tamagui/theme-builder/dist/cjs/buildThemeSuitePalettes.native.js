"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var buildThemeSuitePalettes_exports = {};
__export(buildThemeSuitePalettes_exports, {
  getThemeSuitePalettes: () => getThemeSuitePalettes
});
module.exports = __toCommonJS(buildThemeSuitePalettes_exports);
var import_color2k = require("color2k");
const paletteSize = 12, generateColorPalette = ({
  theme,
  scheme,
  forAccent
}) => {
  const baseTheme = forAccent && theme.accent || theme, { anchors } = baseTheme;
  let palette = [];
  const add = (h, s, l) => {
    palette.push((0, import_color2k.hsla)(h, s, l, 1));
  }, numAnchors = Object.keys(anchors).length;
  for (const [anchorIndex, anchor] of anchors.entries()) {
    const [h, s, l] = [anchor.hue[scheme], anchor.sat[scheme], anchor.lum[scheme]];
    if (anchorIndex !== 0) {
      const lastAnchor = anchors[anchorIndex - 1], steps = anchor.index - lastAnchor.index, lastHue = lastAnchor.hue[scheme], lastSat = lastAnchor.sat[scheme], lastLum = lastAnchor.lum[scheme], stepHue = (lastHue - h) / steps, stepSat = (lastSat - s) / steps, stepLum = (lastLum - l) / steps;
      for (let step = lastAnchor.index + 1; step < anchor.index; step++) {
        const str = anchor.index - step;
        add(h + stepHue * str, s + stepSat * str, l + stepLum * str);
      }
    }
    if (add(h, s, l), anchorIndex === numAnchors - 1 && palette.length < paletteSize)
      for (let step = anchor.index + 1; step < paletteSize; step++)
        add(h, s, l);
  }
  const [background] = palette, foreground = palette[palette.length - 1], transparentValues = [background, foreground].map((color) => {
    const [h, s, l] = (0, import_color2k.parseToHsla)(color);
    return [
      (0, import_color2k.hsla)(h, s, l, 0),
      (0, import_color2k.hsla)(h, s, l, 0.25),
      (0, import_color2k.hsla)(h, s, l, 0.5),
      (0, import_color2k.hsla)(h, s, l, 0.75)
    ];
  }), reverseForeground = [...transparentValues[1]].reverse();
  if (palette = [...transparentValues[0], ...palette, ...reverseForeground], theme.accent) {
    const accentPalette = generateColorPalette({
      theme: theme.accent,
      scheme
    });
    palette.unshift(accentPalette[11]), palette.push(accentPalette[accentPalette.length - 6]);
  } else
    palette.unshift("rgba(0,0,0,0)"), palette.push("rgba(0,0,0,0)");
  return palette;
};
function getThemeSuitePalettes(theme) {
  return {
    light: generateColorPalette({ theme, scheme: "light" }),
    lightAccent: generateColorPalette({ theme, scheme: "light", forAccent: !0 }),
    dark: generateColorPalette({ theme, scheme: "dark" }),
    darkAccent: generateColorPalette({ theme, scheme: "dark", forAccent: !0 })
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getThemeSuitePalettes
});
//# sourceMappingURL=buildThemeSuitePalettes.js.map
